/* gen_eval.c */
/* (C) John Mair 2009
 * This program is distributed under the terms of the MIT License
 *                                                                */

#include <ruby.h>
#include "object2module.h"
#include "compat.h"

VALUE
rb_capture(VALUE self) {
    VALUE hidden_self;
    
    rb_need_block();

    hidden_self = rb_ivar_get(self, rb_intern("__hidden_self__"));

    if(!NIL_P(hidden_self))
        rb_obj_instance_eval(0, 0, hidden_self);
    else
        rb_yield(Qnil);

    return hidden_self;
}

VALUE
rb_gen_eval(int argc, VALUE * argv, VALUE self) {
    VALUE duped_context;
    VALUE is_a_module;
    VALUE context;
        
    rb_need_block();
        
    context = rb_funcall(rb_block_proc(), rb_intern("__context__"), 0);

    /* copy the iv_tbl. 2 cases: (1) external iv_tbl, (2) local iv_tbl */
    if(FL_TEST(context, FL_EXIVAR)) {

        /* using Class instead of Object because Object's iv_tbl setup in 1.9.1 is weird */
        duped_context = rb_funcall(rb_cClass, rb_intern("new"), 0);
        RCLASS_IV_TBL(duped_context) = (struct st_table *) st_copy(rb_generic_ivar_table(context));
        
        /* ensure singleton exists */
        rb_singleton_class(context);
    
        /* set up the class hierarchy for our dup */
        KLASS_OF(duped_context) = rb_singleton_class_clone(context);
    }
    else {
        /* note: we use clone rather than dup so we get singleton methods too */
        duped_context = rb_obj_clone(context);
    }

    /* if no args then default to mixing in 'self' */
    if(argc == 0) {
        argc = 1;
        argv = &self;
    }

    /* mix the objects (or self) into the duped context */
    rb_gen_extend(argc, argv, duped_context);

    /* store self in hidden var in duped context */
    rb_ivar_set(duped_context, rb_intern("__hidden_self__"), self);

    is_a_module = rb_funcall(duped_context, rb_intern("is_a?"), 1, rb_cModule);

    /* eval block wrt duped_context */
    if(is_a_module == Qtrue)
        return rb_mod_module_eval(0, 0, duped_context);
    else
        return rb_obj_instance_eval(0, 0, duped_context);


    return Qnil;
}

void
Init_gen_eval() {

    rb_define_method(rb_cObject, "gen_eval", rb_gen_eval, -1);
    rb_define_method(rb_cObject, "capture", rb_capture, 0);
    
    rb_define_method(rb_cObject, "to_module", rb_to_module , 0);
    rb_define_method(rb_cObject, "reset_tbls", rb_reset_tbls , 0);
    rb_define_method(rb_cObject, "gen_extend", rb_gen_extend, -1);
    rb_define_method(rb_cModule, "gen_include", rb_gen_include, -1);

    /* below is much too hard to achieve in pure C */
    rb_eval_string("class Proc;"
                   "    def __context__;"
                   "        eval('self', self.binding);"
                   "    end;"
                   "end;"
                   );
    
    rb_define_alias(rb_cObject, "gen_eval_with", "gen_eval");
}

    
    

    
